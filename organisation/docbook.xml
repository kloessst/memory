<?xml version="1.0" encoding="UTF-8"?>



<?xml-model href="http://docbook.org/xml/5.0/rng/docbook.rng" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-model href="http://docbook.org/xml/5.0/rng/docbook.rng" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>

<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">
    <info>
        <title> Project - Memory Spiel </title>
        <author>
            <orgname> Stefan Klöss-Schuster </orgname>
        </author>
        <author> <orgname> Vanessa Krohn </orgname> </author>
        <author> <orgname> Ilias Sulgin </orgname> </author>
        <author> <orgname> Alexander Ruhl </orgname> </author>
        <author> <orgname> Daria Beck </orgname> </author>
        
    </info>
    <sect1>
        <title>Setup</title>
        <para>Bevor die Applikation verwendet werden kann müssen folgende Schritte durchgeführt werden:<orderedlist>
                <listitem>
                        <para>Verwendet wird das BaseX plattform-unabhängige ZIP-Package. Der Ordner
                            <emphasis>memory</emphasis>, der den Source Code enthält, muss in dem
                        Ordner <emphasis>basex/webapp </emphasis> abgelegt werden.</para>
                </listitem>
                <listitem>
                    <para>BaseX kann von Haus aus nur mit XSLT Version 1.0 umgehen. In dieser
                        Applikation werden XSLT Version 2.0 Stylesheets verwendet, um eigene
                        XSLT-Funktionen definieren zu können. Hierfür muss ein anderen
                        XSLT-Prozessor, z.B. der <link xlink:href="http://www.saxonica.com/">Saxon
                            XSLT Processor</link>, in den Klassenpfad eingebunden werden. Dazu muss
                        nur die entsprechende .jar Datei in den Ordner
                            <emphasis>lib/custom/</emphasis> abgelegt werden. BaseX erkennt den
                        neuen Prozessor automatisch.</para>
                </listitem>
                <listitem>
                    <para>Die Datenbank muss über die REST-Route
                            <emphasis>/setup/createDB</emphasis> erstellt werden. Wenn die Datenbank
                        erfolgreich angelegt wurde erfolgt eine Weiterleitung auf die
                        Startseite.</para>
                </listitem>
                <listitem>
                    <para>Die SVG-Karten Definitionen müssen über die REST-Route
                            <emphasis>/setup/initSvg</emphasis> erstellt werden. Die
                        Karten-Templates sind in dem Stylesheet
                            <emphasis>svgTemplates.xsl</emphasis> definiert und mit den Stylesheet
                        Variablen aus <emphasis>xsltParameters.xsl</emphasis> parametrisiert. Die
                        REST-Route führt eine XSLT-Transformation durch und speichert das Ergebnis
                        unter <emphasis>static/svgs/svgGameElements.svg</emphasis>.</para>
                </listitem>
                <listitem>
                    <para>Da <link xlink:href="http://www.agencexml.com/xsltforms">XSLT-Forms</link> verwendet wird, muss auch dieses in den Ordner
                        <emphasis>basex/webapp/static</emphasis> eingebunden werden</para>
                </listitem>
            </orderedlist></para>
        <para>Die Applikation wurde mit dem Firefox 62.0 (64-Bit) getestet. Chrome 69.0.3497.100
            (64-Bit) hat Probleme im Zusammenspiel mit XForms und XSLT-Forms. XForms &lt;xf:action>
            Elemente werden nicht richtig ausgeführt wodurch auf der LoadGame-Seite keine
            gespeicherten Spiele gestartet werden können. Außerdem funktioniert deshalb das
            Umschalten zwischen den Karten-Konfigurationen auf der Highscore-Seite nicht.</para>
    </sect1>
    <sect1>
        <title>Use Cases</title>
        <para> Memory Spiel kann in folgende Anwendungsfälle aufgeteilt werden: <itemizedlist>
            <listitem>
                <para> Spieler kann über die Startseite die Lounge anzeigen</para>
            </listitem>
            <listitem>
                <para> Spieler kann in der Lounge zwischen "New Game", "Load Game" und
                    "Highscore" navigieren</para>
            </listitem>
            <listitem>
                <para> Spieler kann ein neues Spiel beginnen. Dabei besteht die Möglichkeit die
                    Anzahl der Karten, die Anzahl der Spieler und die Spielernamen
                    auszuwählen</para>
            </listitem>
            <listitem>
                <para> Spieler kann ein gespeichertes Spiel laden</para>
            </listitem>
            <listitem>
                <para> Spieler kann ein laufendes Spiel über eine Route fortsetzen
                    (/game/"gameID")</para>
            </listitem>
            <listitem>
                <para> Spieler kann ein laufendes Spiel über das Spiel-Menü speichern</para>
            </listitem>
            <listitem>
                <para> Spieler kann ein laufendes Spiel über das Spiel-Menü beenden</para>
            </listitem>
            <listitem>
                <para> Spieler kann einen Highscore erreichen, wenn das abgeschlossen
                    wurde</para>
            </listitem>
            <listitem>
                <para> Spieler kann Highscores für verschiedene Spielkonfigurationen
                    betrachten</para>
            </listitem>
        </itemizedlist></para>
    </sect1>
    <sect1>
        <title> User Experience - Menüführung (UX)</title>
         
              <orderedlist>
            <listitem>
                <para>Zu Beginn werden die SpielerInnen von einer Startseite begrüßt über welche sie
                    durch den Play-Button zum Menü gelangen. Dort steht es den SpielerInnen frei,
                    ein neues Spiel zu starten (Button: New Game), ein bereits angefangenes Spiel zu
                    laden (Button: Load Game) oder zur Highscore-Liste zu gelangen (Button:
                    Highscore). </para>
            </listitem>
            <listitem>
                <para>Wenn die SpielerInnen auf die Option "New Game" klicken, werden sie
                    aufgefordert in das Username-Feld ihren individuellen Nutzernamen einzugeben.
                    Weiterhin müssen sie entscheiden, mit welcher Anzahl von Karten (12,20,28) sie
                    spielen möchten und wie viele TeilnehmerInnen es geben soll. Nachdem alles
                    Nötige angegeben wurde, kann das Spiel über den "Start Game"-Button gestartet
                    werden. Auf eine echte Registrierung der Spieler wird zugunstigen eines
                    "arcade-artigen" Spielerlebnis verzichtet.</para>
            </listitem>
            <listitem>
                <para>Alternativ kann über Load-Game im Menü auch ein bereits gespeichertes Spiel
                    fortgesetzt werden. Die SpielerInnen wählen einfach ihr gespeichertes Spiel aus
                    und setzen dieses mit Klick auf den "Start"-Button fort. Daraufhin erscheint ein
                    Dialog in dem die SpielerInnen das Passwort für das gespeicherte Spiel eingeben
                    müssen. Bei Klick auf den "Cancel-Button" wird der Dialog geschlossen. Mit einem
                    Klick auf den "Load Game"-Button wird das Spiel geladen, falls das Passwort
                    stimmt. Falls nicht werden die SpielerInnen zum Menü weitergeleitet.</para>
            </listitem>
            <listitem>
                <para>Sobald ein Spiel gestartet wird, erscheinen umgedrehte Karten (je nach Auswahl
                    der Kartenanzahl) in der Mitte vom Spielfeld. Am Rand sind die TelnehmerInnen
                    und deren jeweilige Punktzahl gelistet. Die Spielregeln sind die des
                    altbekannten Memorie-Spiels. Die SpielerInnen können jederzeit ihr Spiel
                    abspeichern. Sobald ein Spiel beendet wurde, wird die Spielerin oder der Spieler
                    mit den meisten Punkten als "Gewinner" markiert und die besten Spieler erhalten
                    einen Eintrag in der Highscore-Liste.</para>
            </listitem>
            <listitem>
                <para>Die Highscore-Liste ist ebenfalls über das Menü erreichbar und besteht aus den
                    Nutzernamen und Punktzahl der Zwanzig Spielerinnen und Spieler.</para>
            </listitem>
        </orderedlist> 
        
       
    </sect1>
    <sect1> 
        <title>UML-Klassendiagramm</title>
        <para> Die benötigten Zustandsdaten für ein laufendes Spiel und die Hilfsdaten (Highscore,
            SavedGame) sind im UML-Klassendiagramm dargestellt.<inlinemediaobject>
                <imageobject>
                    <imagedata width="700px" fileref="memoryUMLClass.jpg"/>
                </imageobject>
            </inlinemediaobject></para>
        
        <sect2>
            <title>Datenbeschreibung</title>
            <para>Die folgende Liste beschreibt die Klassen des oben dargestellten UML-Klassendiagramm,
                die für ein laufendes Spiel benötigt werden:<itemizedlist>
                    <listitem>
                        <para>
                            <emphasis>Game</emphasis>: Die Spiel-Klasse repräsentiert eine Instanz eines
                            laufenden Spiels. Das Attribut "id" ist über alle laufenden und
                            gespeicherten Spiele hinweg eindeutig und identifiziert ein Spiel. Ein Spiel
                            wird mit 12, 20 oder 28 Karten gespielt ("numberOfCards") und hat bis zu
                            vier Spieler ("numberOfPlayers"). Über die Spiel-Klasse kann auf die anderen
                            Klassen, welche für ein laufendes Spiel benötigt werden, zugegriffen werden.
                            In XML-codiert ist damit "Game" der Container für die anderen
                            Zustandsklassen.</para>
                    </listitem>
                    <listitem>
                        <para><emphasis>GameState</emphasis>: Diese Klasse repräsentiert Informationen,
                            die für den Spielablauf benötigt werden. Das Attribute "state" vom Typ
                            String gibt an, ob das Spiel beendet ist ("finished") oder noch läuft
                            ("running"). Das Feld "guessPhase" gibt an in welcher Ablaufphase sich das
                            Spiel momentan befindet. Zum Beispiel repäsentiert die "guessPhase=0" die
                            Phase in der die SpielerInnen die ersten Karte aufdecken. Die Karten-Id des
                            ersten und des zweiten Tipps werden in den Feldern "firstGuess" bzw.
                            "secondGuess" gespeichert.</para>
                    </listitem>
                    <listitem>
                        <para>
                            <emphasis>Player</emphasis>: Die Spieler-Klasse repräsentiert einen von
                            maximal vier Spielern. Sie hat eine "id" und einen "username", um einen
                            Spieler zu identifizieren. Jeder Spieler hat einen Integer "score", der die
                            aktuelle Punktzahl des Spielers festhält. Das Attribut "active" gibt an, ob
                            der Spieler gerade an der Reihe ist.</para>
                    </listitem>
                    <listitem>
                        <para><emphasis>GameBoard</emphasis>: Das Spielfeld besteht aus den Karten die
                            aktuell im Spiel sind. Die Attribute "columns" und "rows" bestimmen die
                            Ausmaße des Spielfelds. </para>
                    </listitem>
                    <listitem>
                        <para>
                            <emphasis>Card</emphasis>: Karten werden in Paaren dargestellt. Jede Karte
                            erhält eine eindeutige Id und eine pairId (twin of Assoziation) welche für
                            Zwillingkarten identisch ist. Die Klasse enthält die boolean Attribute
                            "revealed" und "solved". Sie geben an, ob die Karte aufgedeckt ist und ob
                            die Zwillingskarte bereits gefunden wurde. Der String "graphic" assoziiert
                            die Karte mit einem Bilderdatei, die dargestellt wird, wenn die Karte
                            aufgedeckt ist. Die Felder "row" und "column" bestimmen die Position der
                            Karte auf dem Spielbrett.</para>
                    </listitem>
                </itemizedlist></para>
            <para>Die folgende Aufzählung beschreibt Klassen in denen Hilfsdaten gespeichert werden:<itemizedlist>
                <listitem>
                    <para><emphasis>Highscore</emphasis>: Die Klasse Highscore wird benötigt, um die
                        Highscores der Spieler zu speichern. Eine Instanz der Klasse wird nur
                        gespeichert, wenn das Spiel beendet wurde und ein Spieler einen Highscore
                        erreicht hat. Mit Hilfe das Attributs "numberOfCards" kann zwischen den
                        Highscores verschiedener Spielkonfigurationen unterschieden werden. Das
                        Attribut "player" gibt den Namen des Spielers an, "score" enthält die
                        erreichte Punktzahl und "date" hält da fest, wann der Highscore erreicht
                        wurde.</para>
                </listitem>
                <listitem>
                    <para><emphasis>SavedGame</emphasis>: Die Klasse repäsentiert ein gespeichertes
                        Spiel. Neben den Zustandsdaten des gespeicherten Spiels, hat die Klasse die
                        Attribute "gameName" und "gamePassword" welche zum Laden des Spiels benötigt
                        werden. Zusätzlich wird in dem Feld "date" festgehalten, wann das Spiel
                        gespeichert wurde.</para>
                </listitem>
            </itemizedlist></para>
            <para>Die Attribut-Typen, die in dem UML-Klassendiagramm angegeben wurden, dienen lediglich
                zum besseren semantischen Verständnis. Bei der Implementierung kann es vorkommen, dass
                ein Integer (xs:int) als String (xs:string) repräsentiert wird. Außerdem sind die
                Zustandsdaten nicht minimal d.h. Informationen werden teilweise redundant gespeichert.
                Zum Beispiel kann der Wert des Attributs "Game.numberOfCards" über die Assoziation der
                GameBoard-Klasse mit der Karten-Klasse bestimmt werden. Der Vorteil des expliziten
                Speicherns wichtiger Spiel-Parameter ist das einfache Auslesen dieser Werte.</para>
        </sect2>
        <sect2>
            <title>Methodenbeschreibung</title>
            <para>In diesem Kapitel werden einige Methoden aus dem obigen Klassendiagramm erläutert.<itemizedlist>
                    <listitem>
                        <para>Game.createGame(...): Erstellt den Spielzustand. Ruft Konstruktoren
                            der anderen Klassen auf wie z.B. GameState.createGameState(). Verwendet
                            createUniqueGameId() um eine einzigartige Id aus dem Hash der
                            Spielernamen zu erzeugen. Gibt den initialen Spielzustand zurück.</para>
                    </listitem>
                    <listitem>
                        <para>Game.handleCardReveal(): Verändert den Spielzustand abhängig von der
                            aufgedeckten Karte und dem aktuellen GameState.</para>
                    </listitem>
                    <listitem>
                        <para>Game.isGameFinished(): Überprüft, ob das aktuelle Spiel zu Ende ist.
                            Nutzt GameBoard.countSolvedPairs() und numberOfCards.</para>
                    </listitem>
                    <listitem>
                        <para>Game.switchPlayers(): Setzt einen anderen Spieler aktiv. Wird
                            verwendet wenn ein Kartenpaar nicht gefunden wurde</para>
                    </listitem>
                    <listitem>
                        <para>Game.updateHighscore(): Veranlasst eine Aktualisierung des Highscores,
                            wenn das Spiel beendet ist. Ruft Highscore.insertHighscore() auf.</para>
                    </listitem>
                </itemizedlist></para>
        </sect2>
    </sect1>
    
 
    
    <sect1>
        <title>Architektur</title>
        <sect2>
            <title>Überblick</title>
            <para>Die Architektur der Anwendung entspricht der in der Vorlesung vorgestellten
                Model-View-Controller-Architektur mit einer passiven View. </para>
            <para>Die Views werden mit HTML5, SVG und XForms im Zusammenspiel mit XSLTForms realisiert
                und in einem Browser dargestellt. Die eigentliche Spiel-Seite wird aus dem Spielzustand
                mit Hilfe eines XSLT-Programms generiert. Ausgabeformat ist hierbei HTML5 mit
                eingebettetem SVG. Die Views bietet den SpielerInnen Interaktionsmöglichkeiten über
                Links (&lt;a/>), HTML Dialoge (&lt;dialog/>) und HTML Forms. Wenn die SpielerInnen eine
                Interaktion vornehmen, wird ein HTTP-Request mit einer vordefinierten Route abgesendet
                und die Antwort erneut im Browser dargestellt.</para>
            <para>Die Controller-Module haben die Aufgabe die von den Views entsendeten HTTP-Requests zu
                verarbeiten. Das Mapping von HTTP-Requests auf XQuery Methoden erfolgt mit
                RESTXQ-Annotationen. Zur Verarbeitung der HTTP-Requests werden die Funktionen in den
                Model-Modulen benötigt. Ein Design-Ziel ist hierbei den Controller möglichst "dumm" zu
                halten um eine starke "separation of concerns" zu ermöglichen. Das Model hat aus diesem
                Grund eine REST-Schnittstelle, die wiederum über RESTXQ-Annotationen realisiert wird.
                Der Controller greift auf die Model-API über Wrapper-Methoden zu, welche mit
                http:send-request implementiert sind. Der Controller generiert aus den zurückgegebenen
                Informationen eine neue View, die in dem Browser dargestellt wird.</para>
            <para>Das Model kann weiterhin in zwei Schichten unterteilt werden, die Logik und die
                Datenbank-Funktionen. Nur die Controller-Module dürfen die Model-Funktionen aufrufen,
                niemals die Views direkt. Grundsätzlich ist gewollt, dass nur über die Logik-Schicht auf
                die Datenbank-Funktionen zugegriffen wird aber es gibt Außnahmen, falls keine
                vorgeschaltete Logik benötigt wird. Ein Beispiel hierfür ist das Anlegen der Datenbank.
                Aufgabe der Logik-Schicht ist das Manipulieren der Daten.</para>
            <para>Zugriff auf alle Datenbank-Funktionen, sowohl lesend als auch schreibend, erfolgt
                ebenfalls über eine eigene Datenbank-REST-API, die mit RESTXQ Annotationen umgesetzt
                wird. Ein Vorteil dieser Entscheidung ist, dass die aufrufende Methoden einfacher
                gestaltet werden kann. Datenbank-Updates und Lesezugriffe können an beliebiger Stelle in
                der Funktion ausgeführt und vermischt werden. Die Pending Update List wird für jede
                Aufruf einer Datenbank-Funktion direkt verarbeitet. Dadurch muss nicht auf die implizite
                Update-Reihenfolge geachtet werden. Außerdem werden jegliche Deadlocks verhindert und
                das Prinzip der "seperation of concerns" umgesetzt.</para>
        </sect2>
        <sect2>
            <title>REST-API</title>
            <para>Folgende REST-API wird verwendet, um die Applikation zu initialisieren:<table frame="all">
                <title>Setup REST-API</title>
                <tgroup cols="5">
                    <colspec colname="c1" colnum="1"/>
                    <colspec colname="c2" colnum="2"/>
                    <colspec colname="c3" colnum="3"/>
                    <colspec colname="c4" colnum="4"/>
                    <colspec colname="c5" colnum="5"/>
                    <thead>
                        <row>
                            <entry>Controller Module</entry>
                            <entry>Controller Function</entry>
                            <entry>Method</entry>
                            <entry>Path</entry>
                            <entry>Beschreibung</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry morerows="2">setupController.xqm</entry>
                            <entry>sc:createDatabase</entry>
                            <entry>GET</entry>
                            <entry>/setup/createDB</entry>
                            <entry>Initialisiert die Datenbank.</entry>
                        </row>
                        <row>
                            <entry>sc:dropDatabase</entry>
                            <entry>GET</entry>
                            <entry>/setup/dropDB</entry>
                            <entry>Löscht die Datenbank</entry>
                        </row>
                        <row>
                            <entry>sc:initSvg</entry>
                            <entry>GET</entry>
                            <entry>/setup/initSvg</entry>
                            <entry>Erstellt eine Datei mit Karten SVG-Definitionen aus einem
                                XSLT-Programm (svgTemplates.xsl), dass die Kartentemplates enthält.
                                Die Kartentemplates werden mit Variablen in xsltParameters.xsl
                                parametrisiert.</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table></para>
        <para>Folgende REST-API wird in der Controller-Schicht umgesetzt und stellt alle
            Interaktionsmöglichkeiten des Clients dar:<table frame="all">
                <title>Controller REST-API</title>
                <tgroup cols="5">
                    <colspec colname="c1" colnum="1"/>
                    <colspec colname="c2" colnum="2"/>
                    <colspec colname="c3" colnum="3"/>
                    <colspec colname="c4" colnum="4"/>
                    <colspec colname="c5" colnum="5"/>
                    <thead>
                        <row>
                            <entry>Controller Module</entry>
                            <entry>Controller Function</entry>
                            <entry>Method</entry>
                            <entry>Path</entry>
                            <entry>Beschreibung</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry morerows="6">lobbyController.xqm</entry>
                            <entry>lc:start</entry>
                            <entry>GET</entry>
                            <entry>/</entry>
                            <entry>Gibt die Start-Seite als HTML5 zurück</entry>
                        </row>
                        <row>
                            <entry>lc:menu</entry>
                            <entry>GET</entry>
                            <entry>/menu</entry>
                            <entry>Gibt das Lobby Menü als HTML5 zurück</entry>
                        </row>
                        <row>
                            <entry>lc:createGame</entry>
                            <entry>GET</entry>
                            <entry>/createGame</entry>
                            <entry>Gibt die CreateGame-Seite zurück. Diese Seite verwendet XForms
                                und wird mit Hilfe von XSLTForms umgewandelt.</entry>
                        </row>
                        <row>
                            <entry>lc:loadGame</entry>
                            <entry>GET</entry>
                            <entry>/loadGame</entry>
                            <entry>Gibt die LoadGame-Seite zurück. Diese Seite verwendet
                                XForms.</entry>
                        </row>
                        <row>
                            <entry>lc:getSavedGames</entry>
                            <entry>GET</entry>
                            <entry>/savedGames</entry>
                            <entry>Befüllt die XForms Instanz der LoadGame-Seite. Liefert alle
                                gespeicherten Spiele zurück.</entry>
                        </row>
                        <row>
                            <entry>lc:highscores</entry>
                            <entry>GET</entry>
                            <entry>/highscores</entry>
                            <entry>Gibt die Highscores-Seite zurück. Diese Seite verwendet
                                XForms.</entry>
                        </row>
                        <row>
                            <entry>lc:getHighscores</entry>
                            <entry>GET</entry>
                            <entry>/getHighscores</entry>
                            <entry>Befüllt die XForms Instanz der Highscores-Seite. Liefert alle
                                    Highscores der entsprechenden Karten-Konfiguration zurück.
                                    Konfiguration wird mit dem Query-Parameter numberOfCards
                                    angegeben.</entry>
                        </row>
                        <row>
                            <entry morerows="3">gameController.xqm</entry>
                            <entry>gc:createGame</entry>
                            <entry>POST</entry>
                            <entry>/game/create</entry>
                            <entry>Erstellt ein neues Spiel anhand der Parameter numberOfCards,
                                numberOfPlayers und den Spielernamen im Body des Requests. Leitet
                                danach auf die Spielseite weiter.</entry>
                        </row>
                        <row>
                            <entry>gc:createGamePage</entry>
                            <entry>GET</entry>
                            <entry>/game/{$gameId}</entry>
                            <entry>Gibt eine spezifische Spielseite zurück. Die Seite wird aus dem
                                Spielzustands mit einem XSLT-Programm generiert.</entry>
                        </row>
                        <row>
                            <entry>gc:revealCard</entry>
                            <entry>GET</entry>
                            <entry>/game/{$gameId}/ revealCard/{$cardId}</entry>
                            <entry>Diese Route wird aufgerufen wenn ein Spieler eine Karte auswählt
                                hat und verändert den Spielzustand entsprechend. Ersetzt den alten
                                Spielzustand in der Datenbank. Überprüft, ob das Spiel zu Ende ist,
                                speichert eventuell den Highscore und leitet entweder zur Spielseite
                                oder zum Hauptmenü zurück.</entry>
                        </row>
                        <row>
                            <entry>gc:loadGame</entry>
                            <entry>POST</entry>
                            <entry>/game/load</entry>
                            <entry>Wird von der LoadGame-Page augerufen. Body enthält das vom User
                                eingegeben Passwort und die GameId. Überprüft, ob das Passwort
                                übereinstimmt. Falls ja, aktiviert das gespeicherte Spiel und leitet
                                zu der Spiel-Seite weiter. Ansonsten wird zum Lobby-Menü
                                weitergeleitet.</entry>
                        </row>
                        <row>
                            <entry>gameMenuController.xqm</entry>
                            <entry>gmc:saveGame</entry>
                            <entry>POST</entry>
                            <entry>/gameMenu/saveGame</entry>
                            <entry>Wird über das InGame-Menü aufgerufen. Speichert das aktuelle
                                Spiel als savedGame in der Datenbank</entry>
                        </row>
                        <row>
                            <entry/>
                            <entry>gmc:ExitGame</entry>
                            <entry>POST</entry>
                            <entry>/gameMenu/exit</entry>
                            <entry>Löscht das Spiel ein leitet zur LobbyMenu-Seite weiter. Die
                                    gameId wird über eine HTML-Form übermittelt.</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table></para>
        <para> Mit folgender REST-API kann die Logik-Schicht des Models verwendet werden<table frame="all">
                <title>Model Logic REST-API</title>
                <tgroup cols="5">
                    <colspec colname="c1" colnum="1"/>
                    <colspec colname="c2" colnum="2"/>
                    <colspec colname="c3" colnum="3"/>
                    <colspec colname="c4" colnum="4"/>
                    <colspec colname="c5" colnum="5"/>
                    <thead>
                        <row>
                            <entry>Model Module</entry>
                            <entry>Controller Function</entry>
                            <entry>Method</entry>
                            <entry>Path</entry>
                            <entry>Beschreibung</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>gameBoardFunctions.xqm</entry>
                            <entry>gbf:handleCardReveal</entry>
                            <entry>POST</entry>
                            <entry>/model/game/{$gameId}/ revealCard/{$cardId}</entry>
                            <entry>Verändert den Spielzustand eines besimmten Spiels anhand des
                                gespeicherten Spiel-Zustands und der aufzudeckenden Karte. Gibt den
                                veränderten Spiel-Zustand zurück</entry>
                        </row>
                        <row>
                            <entry>gameConstructor.xqm</entry>
                            <entry>gco:createGame</entry>
                            <entry>POST</entry>
                            <entry>/model/game/create</entry>
                            <entry>Erstellt den Spielzustand anhand der XML-codierten Parameter im
                                Body des Requests. Parameter sind die Anzahl der Karten, die Anzahl
                                der Spieler und die Spielernamen. Gibt den XML-codierten
                                Spielzustand zurück.</entry>
                        </row>
                        <row>
                            <entry>gameMenuFunctions.xqm</entry>
                            <entry>gmf:saveGame</entry>
                            <entry>POST</entry>
                            <entry>/model/gameMenu/saveGame</entry>
                            <entry>Erstellt das savedGame anhand der XML-codierten Parameter im Body
                                des Requests. Parameter sind der Spielname, das Passwort und die
                                GameId. Erstellt eine neue einzigartige GameId und speichert das
                                savedGame in der Datenbank</entry>
                        </row>
                        <row>
                            <entry>highscoreFunctions.xqm</entry>
                            <entry>hf:saveHighscores</entry>
                            <entry>POST</entry>
                            <entry>/model/highscore/save</entry>
                            <entry>Erstellt Highscores. Der Body des Requests erhält die
                                Spielernamen und die Scores eines beendeten Spiels. Die globale
                                Variable hf:highscoreLimit bestimmt wieviele Highscores für eine
                                Kartenkonfiguration gespeichert werden. Die alten Highscores der
                                Konfiguration werden aus der Datenbank gelöscht und die neuen
                                Highscores in die Datenbank eingefügt.</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table></para>
        <para> Mit folgender REST-API kann lesend und schreibend auf die Datenbank zugegriffen
                werden:<table frame="all">
                <title>Model Database REST-API</title>
                <tgroup cols="5">
                    <colspec colname="c1" colnum="1"/>
                    <colspec colname="c2" colnum="2"/>
                    <colspec colname="c3" colnum="3"/>
                    <colspec colname="c4" colnum="4"/>
                    <colspec colname="c5" colnum="5"/>
                    <thead>
                        <row>
                            <entry>Model Module</entry>
                            <entry>Controller Function</entry>
                            <entry>Method</entry>
                            <entry>Path</entry>
                            <entry>Beschreibung</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry morerows="13">databaseFunctions.xqm</entry>
                            <entry>%updating dbf:initDatabase</entry>
                            <entry>POST</entry>
                            <entry>/model/database/init</entry>
                            <entry>Erstellt eine Datenbank mit Container-Nodes für die laufenden
                                Spiele, die gespeicherten Spiele und die Highscores. Wird nur
                                erstellt wenn die Datenbank noch nicht existiert.</entry>
                        </row>
                        <row>
                            <entry>%updating dbf:dropDatabase</entry>
                            <entry>POST</entry>
                            <entry>/model/database/drop</entry>
                            <entry>Löscht die Datenbank</entry>
                        </row>
                        <row>
                            <entry>dbf:getGame</entry>
                            <entry>GET</entry>
                            <entry>/model/database/getGame/{$id}</entry>
                            <entry>Gibt den Spielzustand mit der entsprechenden gameId
                                zurück</entry>
                        </row>
                        <row>
                            <entry>%updating dbf:createGame</entry>
                            <entry>POST</entry>
                            <entry>/model/database/createGame</entry>
                            <entry>Speichert den Spielzustand im Body des Requests in der
                                Datenbank</entry>
                        </row>
                        <row>
                            <entry>%updating dbf:replaceGame</entry>
                            <entry>POST</entry>
                            <entry>/model/database/replaceGame</entry>
                            <entry>Ersetzt einen alten Spielzustand mit einem Neuem. Der neue
                                Spielzustand ist im Body des Requests</entry>
                        </row>
                        <row>
                            <entry>%updating dbf:deleteGame</entry>
                            <entry>POST</entry>
                            <entry>/model/database/deleteGame/{$id}</entry>
                            <entry>Löscht den Spielzustand mit der übergebenen gameId aus der
                                Datenbank</entry>
                        </row>
                        <row>
                            <entry>%updating dbf:createSaveGame</entry>
                            <entry>POST</entry>
                            <entry>/model/database/createSaveGame</entry>
                            <entry>Fügt ein savedGame aus dem Body des Requests in die Datenbank
                                ein</entry>
                        </row>
                        <row>
                            <entry>dbf:getAllSavedGames</entry>
                            <entry>GET</entry>
                            <entry>/model/database/getAllSavedGames</entry>
                            <entry>Liefert alles savedGames, die in der Datenbank gespeichert sind,
                                zurück</entry>
                        </row>
                        <row>
                            <entry>dbf:getSavedGame</entry>
                            <entry>GET</entry>
                            <entry>/model/database/ getSavedGame/{$id}</entry>
                            <entry>Gibt ein savedGame mit der entsprechenden gameId aus der
                                Datenbank zurück</entry>
                        </row>
                        <row>
                            <entry>%updating dbf:deleteSavedGame</entry>
                            <entry>POST</entry>
                            <entry>/model/database/d eleteSavedGame/{$id}</entry>
                            <entry>Löscht ein savedGame mit der entsprechenden gameId aus der
                                Datenbank</entry>
                        </row>
                        <row>
                            <entry>dbf:getHighScore</entry>
                            <entry>GET</entry>
                            <entry>/model/database/ highscores/{$numberOfCards}</entry>
                            <entry>Gibt alle Highscores mit der entsprechenden Kartenkonfiguration
                                aus der Datenbank zurück</entry>
                        </row>
                        <row>
                            <entry>%updating dbf:deleteHighScores</entry>
                            <entry>POST</entry>
                            <entry>/model/database/ deleteHighscores/{$numberOfCards}</entry>
                            <entry>Löscht alle Highscores mit der entsprechenden Kartenkonfiguration
                                aus der Datenbank</entry>
                        </row>
                        <row>
                            <entry>%updating dbf:insertHighScore</entry>
                            <entry>POST</entry>
                            <entry>/model/database/insertHighscores</entry>
                            <entry>Fügt alle Highscores, die im Body des Requests sind, in die
                                Datenbank ein</entry>
                        </row>
                        <row>
                            <entry>dbf:gameIdExists</entry>
                            <entry>GET</entry>
                            <entry>/model/database/gameIdExists/{$id}</entry>
                            <entry>Gibt zurück, ob die übergebene gameId bereits in einem laufendem
                                oder gespeicherten Spiel existiert.</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table></para>
        </sect2>
        
        <sect2>
            <title>Spielablauf</title>
            <para>Folgendes UML Zustandsdiagramm zeigt das Konzept des Spielablaufs: <inlinemediaobject>
                    <imageobject>
                        <imagedata width="700px" fileref="UMLZustand-Spielablauf.jpg"/>
                    </imageobject>
                </inlinemediaobject></para>
            <para>Zunächst wird das Spiel über die Route <emphasis>/game/create</emphasis> angelegt.
                Alle relevanten Informationen zum Erstellen des Spiels sind im Body des Requests
                enthalten:</para>
            <para>
                <code> &lt;data&gt; &lt;numberOfCards&gt;20&lt;/numberOfCards&gt;
                    &lt;numberOfPlayers&gt;1&lt;/numberOfPlayers&gt;
                    &lt;players&gt;John&lt;/players&gt; &lt;/data&gt; </code>
            </para>
            <para>Im obigen Beispiel wird ein Spiel mit einem Spieler namens John und 20 Karten
                erstellt. Das Model Modul <emphasis>gameConstructor</emphasis> wird von dem
                    <emphasis>gameController</emphasis> über die REST-Route
                    <emphasis>/model/game/create</emphasis> angesprochen und gibt die XML-codierten
                Daten im Body des Requests weiter. Die Model Funktion generiert aus den
                Spielinformationen einen fertigen Spielzustand. Dabei wird eine einzigartige gameId
                gewählt und zufällige Kartenmotive, die in
                    <emphasis>static/svgs/cardSet.xml</emphasis> festgehalten sind, ausgewählt. Der
                Spielzustand wird über die HTTP-Response and den gameController
                weitergeleitet.</para>
            <para>Der gameController ruft die Route <emphasis>/model/database/createGame</emphasis>
                auf, welche den Spielzustand in der Datenbank speichert. Dann erfolgt eine
                Weiterleitung zur eigentlichen Spiel-Seite <emphasis>/game/{$gameId}</emphasis>. Aus
                unbekannten Grund ändert die Weiterleitung mit <emphasis>web:redirect</emphasis>
                hier nicht die URL, die der Browser anzeigt.</para>
            <para>Die gameController Route<emphasis>/game/{$gameId}</emphasis> hat die Aufgabe aus
                dem Spielzustand eine entsprechende View zu erzeugen. Hierfür wird das XSLT-Programm
                    <emphasis>src/model/xslt/stateToHTML.xsl</emphasis>, welches nach dem
                Pull-Prinzip arbeitet, verwendet. Das Ergebnis-Skelett ist bereits vorgegeben und
                die benötigten Informationen werden aus dem XML-codierten Spielzustand extrahiert.
                Zur Darstellung des Spiels und Berechnen des Layouts werden Hilfsfunktionen aus dem
                Stylesheet <emphasis>src/model/xslt/xsltTemplates.xsl</emphasis> verwendet. Das
                Stylesheet enthält außerdem Variablen zum Parametrisieren der Karten-SVGs und der
                Spieler-Informationen. Die Karten-SVGs müssen bei dem Setup der Applikation über die
                Route <emphasis>/setup/initSvg</emphasis> zunächst initialisiert werden. Die Route
                stößt das XSLT-Programm <emphasis>src/model/xslt/svgTemplates.xsl</emphasis> an und
                schreibt die fertigen Karten-Definitionen in die Datei
                    <emphasis>static/svgs/svgGameElements.svg</emphasis>. Der Vorteil dabei ist,
                dass alle Karten-Grafiken vollständig parametrisiert sind und schnelle Änderungen am
                Design möglich werden.</para>
            <para>Jede verdeckte Karte wird in dem XSLT-Programm
                    <emphasis>src/model/xslt/stateToHTML.xsl</emphasis> mit einem Link zur
                    Route<emphasis> /game/{$gameId}/ revealCard/{$cardId}</emphasis> versehen. Die
                gameId und cardId wird dabei automatisch richtig parametrisiert. Wenn die Spieler
                einen Karte auswählen wird diese Route aufgerufen, um die entsprechenden Änderungen
                am Spielzustand vorzunehmen. </para>
            <para>Der Spielablauf der im obigen UML-Zustandsdiagramm zusammengefasst ist, folgt
                immer dem selben Zyklus:<orderedlist>
                    <listitem>
                        <para>Spieler wählt eine Karte aus und die Route<emphasis> /game/{$gameId}/
                                revealCard/{$cardId}</emphasis> wird aufgerufen</para>
                    </listitem>
                    <listitem>
                        <para>Die entsprechende gameController-Funktion ruft die Model-Route
                                <emphasis>/model/game/{$gameId}/ revealCard/{$cardId}</emphasis>
                            auf, um den Spielzustand zu manipulieren.</para>
                    </listitem>
                    <listitem>
                        <para>Der Spielzustand wird je nach <emphasis>guessPhase</emphasis> in der
                            sich das Spiel aktuell befindet angepasst und an den gameController
                            zurückgegeben. Die guessPhase wird im Spielzustand unter
                                <emphasis>game/gameState/guessPhase</emphasis> gespeichert. <itemizedlist>
                                <listitem>
                                    <para>Die <emphasis>guessPhase = 0</emphasis> repräsentiert den
                                        Zustand in dem der Spieler noch keinen Tipp abgegeben
                                        hat.</para>
                                </listitem>
                                <listitem>
                                    <para>Die <emphasis>guessPhase = 1</emphasis> repäsentiert den
                                        Zustand nach dem der Spieler die erste Karte aufgedeckt
                                        hat.</para>
                                </listitem>
                                <listitem>
                                    <para>Beim Aufdecken der zweiten Karte erfolgt eine
                                        Fallunterscheidung: Falls die zwei Karten nicht identisch
                                        sind wird das Spiel in den Zustand <emphasis>guessPhase =
                                            2</emphasis> versetzt. Falls die Karten identisch sind
                                        wird eine Reihe von Anpassungen am Spielzustand vorgenommen
                                        und das Spiel wieder in den Zustand <emphasis>guessPhase =
                                            0</emphasis> versetzt: Das Kartenpaar wird als "solved"
                                        markiert, der Spieler-Score wird aktualisiert und es wird
                                        überprüft, ob alle Kartenpaare gefunden wurde. Wenn alle
                                        Kartenpaare gefunden sind, wird "finished" in
                                            <emphasis>game/gameState/state</emphasis> hinterlegt.
                                        Der Controller überprüft dieses Flag später.</para>
                                </listitem>
                                <listitem>
                                    <para>Die <emphasis>guessPhase = 2</emphasis> ist der Zustand
                                        der es ermöglicht, dass die fälschlicherweise aufgedeckten
                                        Karten zunächst offen liegen bleiben, damit die Spieler sich
                                        die Karten einprägen können. Bei Klick auf eine verdeckte
                                        Karte werden die fälschlicherweise aufgedeckten Karten
                                        wieder umgedreht, der aktive Spieler gewechselt und in die
                                        guessPhase = 0 zurückgekehrt. Eine Überprüfung, ob das Spiel
                                        beendet ist, erübrigt sich, da das Spiel nur nach dem
                                        Auffinden von zwei identische Karten beendet werden
                                        kann.</para>
                                </listitem>
                            </itemizedlist></para>
                    </listitem>
                    <listitem>
                        <para>Der gameController ersetzt den alten Spielzustand mit dem neuen
                            Spielzustand über die Route
                                <emphasis>/model/database/replaceGame</emphasis>.</para>
                    </listitem>
                    <listitem>
                        <para>Der gameController überprüft, ob das Spiel fertig ist anhand des Werts
                            im Spielzustand <emphasis>game/gameState/state</emphasis>. Wenn das
                            Spiel beendet ist wird die Highscore-Logik über die Route
                                <emphasis>/model/highscore/save</emphasis> angestoßen, um eventuelle
                            Highscores der Spieler zu speichern. Das Spiel wird über die Route
                                <emphasis>/model/database/deleteGame/{$gameId}</emphasis> aus der
                            Datenbank gelöscht und es erfolgt eine Weiterleitung auf die
                            LobbyMenu-Seite. Wenn das Spiel noch nicht fertig ist erfolgt eine
                            Weiterleitung über <emphasis>/game/{$gameId}</emphasis>, um den
                            aktualisierten Spielzustand zu einer View zu transformieren. Hier
                            beginnt der Zyklus erneut.</para>
                    </listitem>
                </orderedlist></para>
            <para>Ein Problem bei dieser Umsetzung des Spiels ist, dass jedes Mal wenn eine Karte
                gewählt wurde ein HTTP-Request gesendet wird und der Client auf die Antwort warten
                muss. Außerdem wird dadurch die Spielseite ständig neu geladen. Eine andere Lösung
                wäre aber mit Logik im Client verbinden, zum Beispiel JavaScript oder XForms. Auf
                JavaScript wurde im ganzen Projekt verzichtet, um die Projektvorgaben einzuhalten.
                Auf XForms mit XSLTForms wurde auf der Spiel-Seite ebenfalls verzichtet, um ständige
                XSLT-Transformationen zu vermeiden und die Komplexität im Zaum zu halten.</para>
        </sect2>
        
    </sect1>
    
   <sect1> 
        <title>Reflektion</title>
        <sect2>
            <title> Organisation der Arbeit </title>
            <para>
                Zur Versionsverwaltung des Source Codes wurde Git im Zusammenspiel mit GitHub
                    verwendet. Sämtliche Arbeitsprodukte sind in dem Repository <link xlink:href="https://github.com/kloessst/memory"/> zu finden. Als
                    Entwicklungsprozess wurde ein vereinfachtes GitFlow vorgeschlagen. Dabei darf
                    der Master Branch immer nur funktionierende Product Increments enthalten. Neue
                    Features werden auschließlich in den Feature Branches entwickelt. Bei
                    Fertigstellung eines Features wird ein Pull-Request erstellt und nach einem
                    Review und Test durch einen zweiten Entwickler in den Master Branch gemerged.
                    Leider konnte dieser Prozess nicht vollständig umgesetzt werden, wegen
                    Zeitmangel und unterschiedlichen Wissensständen im Umgang mit Git und GitHub.
                
            </para>
            <para>Die Kommunikation erfolgte hauptsächlich über eine Whatsapp Gruppe und hat
                grundsätzlich sehr gut funktioniert. Während des Semesters wurden einige Treffen
                veranstaltet, um den Arbeitsablauf zu besprechen. Die restliche Arbeit am Projekt
                erfolgte remote. Die Verteilung der Aufgaben war problematisch. Es wurde versucht
                die Aufgaben nach Wissensständen zu verteilen. Da aber die Team-Mitglieder
                unterschiedlichste Hintergünde haben, wurde die Arbeitslast, vorallem bei der
                Implementierung, nicht fair verteilt. Das Verteilen der Arbeit nach Wissensstand hat
                außerdem zur Folge, dass die XStack-Applikation nicht von jedem vollständig
                überblickt wird. Zusätzlich wurde die Komplexität des Projekts unterschätzt und
                schließlich musste das Testat verschoben werden.</para>
        </sect2> 
        
        <sect2>
            <title> Praktikum</title>
            <para>Die Aufgabe ein Memory Browser-Game zu entwickeln hat allen sehr gefallen. Bei
                einem Spiel besteht die Möglichkeit sich beim Design auszuleben. Außerdem sind
                Fortschritte schnell ersichtlich.</para>
            <para>Der vorgegebene Technologie-Stack konnte den Programmier-Horizont deutlich
                erweitern. Das Arbeitet mit BaseX ging leicht von der Hand dank dem ausführlichen
                Wiki und der vielen vorgefertigten Module. Nachteil des XStacks ist vor allem das
                schwierige Debuggen von fehlerhaften Code, die oft veralteten Informationen im Web
                und die Tatsache, dass der XStack kaum Verwendung findet in der Wirtschaft.</para>
            <para>Die Organisation Praktikums war von Anfang an klar verständlich. Die Tatsache,
                dass die Arbeitsblätter nicht abgegeben werden müssen, hilft den Studierenden, die
                eine hohe Arbeitsbelastung haben. Dies ermöglicht eine flexiblere Arbeitseinteilung.
                Jedoch besteht auch die Gefahr, dass der Anschluss schnell verpasst wird, da die
                XML-Technologien oft aufeinander aufbauen. Die Möglichkeit einen Notenbonus zu
                verdienen, wenn ein Arbeitsblatt präsentiert wird, ist eine gute Maßnahme
                dagegen.</para>
            <para>Die Betreuung des Praktikums war sehr gut. Philipp Ulrich war über E-Mail und die
                Sprechstunden immer zu erreichen und hat schnelle und gute Antworten auf die Fragen
                gegeben. Prof. Dr. Anne Brüggemann-Klein war auch immer erreichbar. An dieser Stelle
                muss die freundliche und kulante Art von Ihr nochmals hervorgehoben werden. </para>
        </sect2>        
    </sect1>
    
   
       
     
</article>
